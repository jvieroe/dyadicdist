---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "85%",
  dpi = 300,
  fig.align = "center"
)
```

# dyadicdist

<!-- badges: start -->
<!-- badges: end -->

The purpose of `dyadicdist` is to provide quick and easy calculation of dyadic distances between geo-referenced points.

The main contribution of `dyadicdist::ddist()` is that the output is stored as a long dyadic `tibble` with dimensions `((N * N), 2)` (number of rows vary with specified `options`) as opposed to a wide `matrix` with dimensions `N * N`.

## Quick example
A simple example with no additional illustrates the workings of `dyadicdist::ddist()`. It takes as input a `data.frame` or a `tibble` and returns a `tibble` with dyadic distances for any combination of points `i` and `j` (see more below)

```{r, warning=F, message=F}
library(dyadicdist)
library(tidyverse)

df <- tibble::tribble(
  ~city_name, ~idvar, ~latitude, ~longitude,
  "copenhagen", 5, 55.68, 12.58,
  "stockholm", 2, 59.33, 18.07,
  "oslo", 51, 59.91, 10.75
)

dyadicdist::ddist(data = df,
                  id = "idvar")

```


## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
if(!require("devtools")) install.packages("devtools")
library(devtools)
devtools::install_github("jvieroe/dyadicdist")
```
## Working example: US cities

Below, I describe some of the key features and important options of `dyadicdist::ddist()`.

Let's use some data on the 100 largest US cities as a working example!

```{r getdata, warning=F, message=F}
library(tidyverse)
library(magrittr)
library(janitor)
library(rvest)
```

First, get the city data using `rvest`:

```{r, warning=F, message=F}
city_url <- "https://www.latlong.net/category/cities-236-15.html"

cities <- city_url %>%
   read_html() %>%
   html_nodes("table")

cities <- rbind(html_table(cities[[1]])) %>% 
  janitor::clean_names()

cities <- cities %>% 
  mutate(city = sapply(strsplit(as.character(cities$place_name),","), "[", 1),
         state = sapply(strsplit(as.character(cities$place_name),","), "[", 2),
         country = sapply(strsplit(as.character(cities$place_name),","), "[", 3)) %>% 
  select(-place_name)

cities <- cities %>% 
  mutate(id = row_number())

# Inspect it!
cities

```

Let's have a look at the data from a more obvious point of view: the cities' geographic location!

```{r, warning=F, message=F, fig.width=5.65, fig.height=3.0}
# Plot the cities
library(sf)
library(rnaturalearth)
library(rgeos)

usa <- rnaturalearth::ne_countries() %>% 
  sf::st_as_sf() %>% 
  filter(admin == "United States of America")

usa <- usa %>% 
  st_crop(.,
          st_bbox(c(xmin = -128,
                    xmax = -57,
                    ymin = 20,
                    ymax = 50),
                  crs = st_crs(usa)))

city_sf <- cities %>% 
  st_as_sf(.,
           coords = c("longitude", "latitude"),
           crs = 4326)

ggplot() +
  geom_sf(data = usa,
          fill = "grey25",
          color = "white") +
  geom_sf(data = city_sf,
          size = 2,
          shape = 21,
          fill = "chartreuse3", color = "NA",
          alpha = .55) +
  geom_sf(data = city_sf,
          size = 2,
          shape = 21,
          fill = "NA", color = "chartreuse3",
          alpha = 1.0) +
  theme_void() +
  theme(panel.background = element_rect(fill = "#0D1117"),
        plot.background = element_rect(fill = "#0D1117"))
  

```

## Basic functionality
`dyadicdist::ddist()` has certain key inputs. It takes a `data.frame` or `tibble` with specified latitude and longitude variables as input. Furthermore, it requires the specification of a unique id variable which can be either `numeric`, `integer`, `factor`, or `character`.

```{r, warning=F, message=F}
dyadicdist::ddist(cities,
                  id = "id")

```
As a default, latitude/longitude are specified as `"latitude"` and `"longitude"`, respectively, and don't need manual inputs. If necessary their variable names can be specified in the `ddist()` call:

```{r, warning=F, message=F}
cities_new <- cities %>% 
  rename(lat = latitude,
         lon = longitude)

dyadicdist::ddist(cities_new,
                  id = "id",
                  latitude = "lat",
                  longitude = "lon") %>% 
  head(2)

```

## Output specification
As a default, `ddist()` returns the full list of dyadic distances between any points `i` and `j`. This includes

* dyads between any observation and itself, i.e. dyads of type `(i,i)` (see example above)
* duplicated dyads, i.e. both `(i,j)` and `(j,i)`

Both of these are optional however. 

* Sort out `(i,i)` dyads (the diagonal in a distance matrix) by specifying `diagonal = FALSE`
* Sort out duplicated dyads by specifying `duplicates = FALSE`

### Let's compare the outputs!

The default call should return a `tibble` where the number of dyads is equal to:
```{r, warning=F, message=F}
nrow(cities)*nrow(cities)
dyadicdist::ddist(cities,
                  id = "id") %>% 
  nrow()
```

With `diagonal = FALSE` the number of dyads should be equal to:
```{r, warning=F, message=F}
nrow(cities) * (nrow(cities)-1)
dyadicdist::ddist(cities,
                  id = "id",
                  diagonal = FALSE) %>% 
  nrow()
```

with `duplicates = FALSE` the number of dyads should be equal to:
```{r, warning=F, message=F}
(nrow(cities) * (nrow(cities)-1)/2)+nrow(cities)
dyadicdist::ddist(cities,
                  id = "id",
                  duplicates = FALSE) %>% 
  nrow()
```

With `diagonal = FALSE` and `duplicates = FALSE` the number of dyads should be equal to:
```{r, warning=F, message=F}
(nrow(cities) * (nrow(cities)-1)/2)
dyadicdist::ddist(cities,
                  id = "id",
                  diagonal = FALSE,
                  duplicates = FALSE) %>% 
  nrow()

```
