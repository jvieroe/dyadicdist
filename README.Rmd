---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "85%",
  dpi = 300,
  fig.align = "center"
)
```

# dyadicdist

<!-- badges: start -->
<!-- badges: end -->

The purpose of `dyadicdist` is to provide quick and easy calculation of dyadic distances between geo-referenced points.

The main contribution of `dyadicdist::ddist()` is that the output is stored as a long dyadic `tibble` as opposed to a wide `matrix`.

This is a very early development version of `dyadicdist`. Additional functions and improved functionality will be added in the immediate future. Please don't hesitate to let me know of any errors you might come across.

## Quick example
A simple example with no additional illustrates the workings of `dyadicdist::ddist()`. It takes as input a `data.frame` or a `tibble` and returns a `tibble` with dyadic distances for any combination of points `i` and `j` (see more below)

```{r, warning=F, message=F}
library(dyadicdist)
library(tidyverse)

df <- tibble::tribble(
  ~city_name, ~idvar, ~latitude, ~longitude,
  "copenhagen", 5, 55.68, 12.58,
  "stockholm", 2, 59.33, 18.07,
  "oslo", 51, 59.91, 10.75
)

dyadicdist::ddist(data = df,
                  id = "idvar")

```


## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
if(!require("devtools")) install.packages("devtools")
library(devtools)
devtools::install_github("jvieroe/dyadicdist")
```
## Working example: US cities

Below, I describe some of the key features of `dyadicdis`. Let's use some data on the 100 largest US cities as a working example!

```{r, warning=F, message=F, fig.width=5.65, fig.height=3.0}
cities <- dyadicdist::cities
usa <- dyadicdist::usa

```

Let's have a look at the cities' geographic location in the US:

```{r, warning=F, message=F, fig.width=5.65, fig.height=3.0}
library(sf)

city_sf <- cities %>%
  st_as_sf(.,
           coords = c("longitude", "latitude"),
           crs = 4326)

ggplot() +
  geom_sf(data = usa,
          fill = "grey25",
          color = "white") +
  geom_sf(data = city_sf,
          size = 2,
          shape = 21,
          fill = "chartreuse3", color = "NA",
          alpha = .55) +
  geom_sf(data = city_sf,
          size = 2.5,
          shape = 21,
          fill = "NA", color = "chartreuse3",
          alpha = 1.0) +
  theme_void() +
  theme(panel.background = element_rect(fill = "#0D1117"),
        plot.background = element_rect(fill = "#0D1117"))
  

```

## Basic functionality
`dyadicdist::ddist()` has __two key inputs__. It requires a `data.frame` or `tibble` with specified latitude and longitude variables. Furthermore, it requires the specification of a unique id variable which can be either `numeric`, `integer`, `factor`, or `character`.

```{r, warning=F, message=F}
dyadicdist::ddist(cities,
                  id = "id")

```
As a default, latitude/longitude are specified as `"latitude"` and `"longitude"`, respectively, and don't need manual inputs. If necessary their variable names can be specified in the `ddist()` call:

```{r, warning=F, message=F}
cities_new <- cities %>% 
  rename(lat = latitude,
         lon = longitude)

dyadicdist::ddist(cities_new,
                  id = "id",
                  latitude = "lat",
                  longitude = "lon") %>% 
  head(2)

```

## Output specification
By default, `ddist()` returns the full list of dyadic distances between any points `i` and `j`, including `j = i`. 

In total, this amount to `nrow(data) * nrow(data)` dyads and includes by default:

* dyads between any observation and itself, i.e. dyads of type `(i,i)` (see example above)
* duplicated dyads, i.e. both `(i,j)` and `(j,i)`

Both of these inclusions are optional, however. 

* Sort out `(i,i)` dyads (the diagonal in a distance matrix) by specifying `diagonal = FALSE`
    + returns a `tibble` with `nrow(data) * (nrow(data)-1)` dyads
* Sort out duplicated dyads by specifying `duplicates = FALSE`
    + returns a `tibble` with `(nrow(data) * (nrow(data)-1)/2)+nrow(data)` dyads
* Sort out both by specifying `diagonal = FALSE` __and__ `duplicates = FALSE`
    + returns a `tibble` with `(nrow(data) * (nrow(data)-1)/2)` dyads


## CRS transformations
By default `ddist()` assumes unprojected coordinates in basic latitude/longitude format (EPSG code `4326`) when converting the raw data provided in the `data` argument to a spatial feature. This is consistent with the default when converting latitude/longitude data to spatial features in the `sf` package (see `sf::st_as_sf()`). You can apply a different CRS by providing a valid EPSG code of type `numeric` with the `crs` argument.

Additionally, `ddist()` allows you to transform the CRS before calculating dyadic distances using the `crs_transform` and `new_crs` arguments:

```{r, warning=F, message=F}
dyadicdist::ddist(cities,
                  id = "id",
                  crs_transform = T,
                  new_crs = 3359)

```

Note that the choice of CRS may impact your results considerably. For more information on choosing an appropriate CRS, see [here](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-to-coordinate-reference-systems/), [here](https://docs.qgis.org/3.4/en/docs/gentle_gis_introduction/coordinate_reference_systems.html), [here](https://www.nceas.ucsb.edu/sites/default/files/2020-04/OverviewCoordinateReferenceSystems.pdf), and [here](http://www.geo.hunter.cuny.edu/~jochen/gtech201/lectures/lec6concepts/map%20coordinate%20systems/how%20to%20choose%20a%20projection.htm)


# Acknowledgements

* The R Core Team for developing and maintaining the language
* The authors of the amazing `sf` package. `sf` has greatly reduced barriers to entry for anyone working with spatial data in `R` and those who wish to do so 
    + Edzer Pebesma ([edzer](https://github.com/edzer))
    + Roger Bivand ([rsbivand](https://github.com/rsbivand))
    + Etienne Racine ([etiennebr](https://github.com/etiennebr))
    + Michael Sumner ([mdsumner](https://github.com/mdsumner))
    + Ian Cook ([ianmcook](https://github.com/ianmcook))
    + Tim Keitt ([thk686](https://github.com/thk686))
    + Robin Lovelace ([Robinlovelace](https://github.com/Robinlovelace))
    + Hadley Wickham ([hadley](https://github.com/hadley))
    + Jeroen Ooms ([jeroen](https://github.com/jeroen))
    + Kirill MÃ¼ller ([krlmlr](https://github.com/krlmlr))
    + Thomas Lin Pedersen ([thomasp85](https://github.com/thomasp85))
    + Dan Baston ([dbaston](https://github.com/dbaston))
    + Dewey Dunnington ([paleolimbot](https://github.com/paleolimbot))
* [Natural Earth](https://www.naturalearthdata.com/) for map data for the working example
* [LatLong.net](https://www.latlong.net/category/cities-236-15.html) for city data for the working example

