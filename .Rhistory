id_x = "id",
id_y = "id") %>%
head(5)
ca <- cities %>%
filter(state == "CA")
ddist_xy(x = fl,
y = ca,
id_x = "id",
id_y = "id") %>%
head(5)
library(devtools)
devtools::install_github("jvieroe/dyadicdist")
``` r
if(!require("devtools")) install.packages("devtools")
library(devtools)
devtools::install_github("jvieroe/dyadicdist", force = T)
library(tidyverse)
library(dyadicdist)
df <- tibble::tribble(
~city_name, ~idvar, ~latitude, ~longitude,
"copenhagen", 5, 55.68, 12.58,
"stockholm", 2, 59.33, 18.07,
"oslo", 51, 59.91, 10.75
)
ddist(data = df,
id = "idvar")
library(dyadicdist)
library(tidyverse)
library(magrittr)
cities <- dyadicdist::cities
ddist(cities,
id = "id") %>%
head(5)
cities %>%
rename(lat = latitude,
lon = longitude) %>%
ddist(.,
id = "id",
latitude = "lat",
longitude = "lon") %>%
head(5)
library(sf)
cities %>%
st_as_sf(.,
coords = c("longitude", "latitude"),
crs = 4326) %>%
ddist_sf(.,
id = "id") %>%
head(5)
fl <- cities %>%
filter(state == "FL")
ca <- cities %>%
filter(state == "CA") %>%
rename(id_var = id)
ddist_xy(x = fl,
y = ca,
id_x = "id",
id_y = "id_var") %>%
head(5)
fl <- cities %>%
filter(state == "FL") %>%
st_as_sf(coords = c("longitude", "latitude"),
crs = 4326)
ca <- cities %>%
filter(state == "CA") %>%
rename(id_var = id) %>%
st_as_sf(coords = c("longitude", "latitude"),
crs = 4326)
ddist_xy(x = fl,
y = ca,
id_x = "id",
id_y = "id_var") %>%
head(5)
ddist_xy_sf(x = fl,
y = ca,
id_x = "id",
id_y = "id_var") %>%
head(5)
library(devtools)
library(roxygen2)
install.packages("newsmd")
library(newsmd)
my_news <- newsmd()
my_news$add_version("0.2.1")
library(devtools)
library(roxygen2)
library(devtools)
library(roxygen2)
check()
devtools::release()
check_rhub()
library(devtools)
library(roxygen2)
document()
document()
library(devtools)
library(roxygen2)
document()
document()
document()
library(devtools)
library(roxygen2)
document()
library(devtools)
library(roxygen2)
spell_check()
usethis::use_version("minor")
install.packages("newsmd")
library(newsmd)
library(newsmd)
my_news <- newsmd()
library(newsmd)
my_news <- newsmd()
install.packages(desc)
library(desc)
library(desc)
library(newsmd)
library(desc)
newsmd::my_news <- newsmd()
my_news$add_version("0.1.0")
my_news$add_subtitle("Package launch")
my_news$add_bullet(c("Launch of package", "Functionality includes single data input"))
my_news$add_version("0.2.0")
my_news$add_subtitle("Dual data inputs")
my_news$add_bullet(c("Added functionality: dual data input", "Bug fixes"))
my_news$add_version("0.2.1")
my_news$add_subtitle("Bug fixes")
my_news$add_bullet(c("Added functionality: dual data input", "Bug fixes"))
my_news$add_version("0.3.0")
my_news$add_subtitle("New input format for dual data functions")
my_news$add_bullet(c("Changed the input format to e.g. ids = c(...)"))
my_news$get_text()
newsmd::my_news$get_text()
library(newsmd)
library(desc)
newsmd::my_news <- newsmd()
library(newsmd)
library(desc)
my_news <- newsmd::newsmd()
my_desc$bump_version("patch")
my_news$add_version(my_desc$get_version())
library(newsmd)
my_news <- newsmd::newsmd()
my_news$add_version("0.1.0")
my_news$add_subtitle("Package launch")
my_news$add_bullet(c("Launch of package", "Functionality includes single data input"))
my_news$add_version("0.2.0")
my_news$add_subtitle("Dual data inputs")
my_news$add_bullet(c("Added functionality: dual data input", "Bug fixes"))
my_news$add_version("0.2.1")
my_news$add_subtitle("Bug fixes")
my_news$add_bullet(c("Added functionality: dual data input", "Bug fixes"))
my_news$add_version("0.3.0")
my_news$add_subtitle("New input format for dual data functions")
my_news$add_bullet(c("Changed the input format to e.g. ids = c(...)"))
my_news$get_text()
my_news$write()
document()
rm(my_news)
rm(newsmd)
library(devtools)
library(roxygen2)
spell_check()
devtools::release()
check()
devtools::release()
check_rhub()
check()
devtools::release()
check_rhub()
library(devtools)
library(roxygen2)
check()
library(devtools)
devtools::install_github("jvieroe/dyadicdist")
library(roxygen2)
libra
library(devtools)
document()
toBibtex(citation("xaringan"))
toBibtex(citation("dyadicdist"))
toBibtex(citation("dyadicdist"))
library(devtools)
devtools::install_github("jvieroe/dyadicdist")
toBibtex(citation("dyadicdist"))
knitr::write_bib(c("dyadicdist", "rmarkdown"), width = 60)
knitr::write_bib(c("dyadicdist"), width = 60)
library(devtools)
devtools::install_github("jvieroe/dyadicdist")
knitr::write_bib(c("dyadicdist"), width = 80)
?nrow
library(devtools)
library(roxygen2)
document()
document()
library(testthat)
library(dyadicdist)
test_check("dyadicdist")
library(devtools)
install_github("jvieroe/dyadicdist")
library(devtools)
library(roxygen2)
usethis::use_testthat()
library(devtools)
library(roxygen2)
usethis::use_testthat()
use_test()
use_test()
use_test()
use_test()
use_test()
use_test()
test_that("multiplication works", {
expect_equal(2 * 2, 4)
})
library(testthat)
library(testthat)
library(dyadicdist)
test_check("dyadicdist")
test_that("multiplication works", {
expect_equal(2 * 2, 4)
})
expect_equal(10, 10 + 1e-7)
expect_identical(10, 10 + 1e-7)
expect_equal(10, 10 + 1e-7)
expect_identical(10, 10 + 1e-7)
log(-1)
test_that()
test_that("str_length is number of characters", {
expect_equal(str_length("a"), 1)
expect_equal(str_length("ab"), 2)
expect_equal(str_length("abc"), 3)
})
use_test()
?context
df <- dyadicdist::cities
library(dplyr)
library(magritrr)
df <- dyadicdist::cities
library(magrittr)
library(dplyr)
library(magrittr)
context("Test input data")
df_sf <- df %>%
sf::st_as_sf(coords = c("longitude", "latitude"),
crs = 4326)
df_1 <- df %>%
filter(state == "CA")
df_2 <- df %>%
filter(state == "TX")
df_sf_1 <- df_sf %>%
filter(sstate == "CA")
df_sf_1 <- df_sf %>%
filter(state == "CA")
df_sf_2 <- df_sf %>%
filter(state == "TX")
ny <- df %>%
filter(city == "New York City")
View(ny)
ny <- df %>%
filter(city == "New York")
rm(ny)
chicago <- df %>%
filter(city == "Chicago")
chicago <- df %>%
filter(city == "chicago")
View(chicago)
View(df)
rm(chicago)
kc <- df %>%
filter(city == "Kansas City")
dup <- rbind(df,
kc)
test_that(
"duplicate IDs not allowed in mono input functions",
expect_error(
dyadicdist::ddist(data = dup,
id = "id")
)
)
test_that(
"duplicate IDs not allowed in mono input functions" {
expect_error(
dyadicdist::ddist(data = dup,
id = "id")
)
}
)
test_that(
"duplicate IDs not allowed in mono input functions" {
expect_error(dyadicdist::ddist(data = dup,
id = "id"))
}
)
test_that(
"duplicate IDs not allowed in mono input functions", {
expect_error(dyadicdist::ddist(data = dup,
id = "id"))
}
)
test_that(
"duplicate IDs not allowed in mono input functions", {
expect_error(dyadicdist::ddist(data = df,
id = "id"))
}
)
test_that(
"duplicate IDs not allowed in mono input functions", {
expect_error(dyadicdist::ddist(data = dup,
id = "id"),
regexp = "xx")
}
)
test_that(
"duplicate IDs not allowed in mono input functions", {
expect_error(dyadicdist::ddist(data = dup,
id = "id"),
regexp = "ID does not uniquely identify rows, duplicates exist")
}
)
context("Test input data")
library(dplyr)
library(magrittr)
df <- dyadicdist::cities
df_sf <- df %>%
sf::st_as_sf(coords = c("longitude", "latitude"),
crs = 4326)
df_1 <- df %>%
filter(state == "CA")
df_2 <- df %>%
filter(state == "TX")
df_sf_1 <- df_sf %>%
filter(state == "CA")
df_sf_2 <- df_sf %>%
filter(state == "TX")
kc <- df %>%
filter(city == "Kansas City")
kc_sf <- df_sf %>%
filter(city == "Kansas City")
dup <- rbind(df,
kc)
dup_sf <- rbind(df_sf,
kc_sf)
test_that(
"duplicate IDs not allowed in mono input functions", {
expect_error(dyadicdist::ddist(data = dup,
id = "id"),
regexp = "ID does not uniquely identify rows, duplicates exist")
expect_error(dyadicdist::ddist(data = dup_sf,
id = "id"),
regexp = "ID does not uniquely identify rows, duplicates exist")
}
)
test_that(
"duplicate IDs not allowed in mono input functions", {
expect_error(dyadicdist::ddist(data = dup,
id = "id"),
regexp = "ID does not uniquely identify rows, duplicates exist")
expect_error(dyadicdist::ddist_sf(data = dup_sf,
id = "id"),
regexp = "ID does not uniquely identify rows, duplicates exist")
}
)
test_that(
"missing/wrong IDs not allowed in", {
expect_error(dyadicdist::ddist(data = df),
regexp = "ID does not uniquely identify rows, duplicates exist")
expect_error(dyadicdist::ddist_sf(data = df_sf),
regexp = "ID does not uniquely identify rows, duplicates exist")
}
)
test_that(
"missing/wrong IDs not allowed in", {
expect_error(dyadicdist::ddist(data = df),
regexp = "No id variable provided")
expect_error(dyadicdist::ddist_sf(data = df_sf),
regexp = "No id variable provided")
}
)
test_that(
"missing/wrong IDs not allowed in", {
expect_error(dyadicdist::ddist(data = df),
regexp = "No id variable provided")
expect_error(dyadicdist::ddist_sf(data = df_sf),
regexp = "No id variable provided")
expect_error(dyadicdist::ddist(data = df,
id = "test"),
regexp = "No id variable provided")
expect_error(dyadicdist::ddist_sf(data = df_sf,
id = "test"),
regexp = "No id variable provided")
}
)
test_that(
"missing/wrong IDs not allowed in", {
expect_error(dyadicdist::ddist(data = df),
regexp = "No id variable provided")
expect_error(dyadicdist::ddist_sf(data = df_sf),
regexp = "No id variable provided")
expect_error(dyadicdist::ddist(data = df,
id = "test"),
regexp = "The provided id variable is not present in data.")
expect_error(dyadicdist::ddist_sf(data = df_sf,
id = "test"),
regexp = "The provided id variable is not present in data.")
}
)
test_that(
"wrong IDs not allowed in", {
expect_error(dyadicdist::ddist(data = df,
id = "test"),
regexp = "The provided id variable is not present in data.")
expect_error(dyadicdist::ddist_sf(data = df_sf,
id = "test"),
regexp = "The provided id variable is not present in data.")
}
)
class(df)
is.data.frame(df)
mat <- df %>% as.matrix()
mat
test_that(
"only data.frames/tibbles allowed as input data in ddist()", {
expect_error(dyadicdist::ddist(data = mat,
id = "test"),
regexp = "Inputdata must be a data.frame or similar.")
}
)
test_that(
"only data.frames/tibbles allowed as input data in ddist()", {
expect_error(dyadicdist::ddist(data = df_sf,
id = "test"),
regexp = "Inputdata must be a data.frame or similar.")
}
)
test_that(
"only data.frames/tibbles allowed as input data in ddist()", {
expect_error(dyadicdist::ddist(data = mat,
id = "test"),
regexp = "Inputdata must be a data.frame or similar.")
}
)
expect_error(dyadicdist::ddist_sf(data = df,
id = "test"),
regexp = "Inputdata must be a data.frame or similar.")
test_that(
"only data.frames/tibbles allowed as input data in ddist()", {
expect_error(dyadicdist::ddist_sf(data = df,
id = "test"),
regexp = "Inputdata must be a data.frame or similar.")
}
)
test_that(
"only data.frames/tibbles allowed as input data in ddist()", {
expect_error(dyadicdist::ddist_sf(data = df,
id = "test"),
regexp = "Inputdata must be an object of class sf. Use dyadicdist::ddist()")
}
)
test_that(
"only data.frames/tibbles allowed as input data in ddist()", {
expect_error(dyadicdist::ddist(data = mat,
id = "id"),
regexp = "Inputdata must be a data.frame or similar.")
}
)
test_that(
"only data.frames/tibbles allowed as input data in ddist()", {
expect_error(dyadicdist::ddist_sf(data = df,
id = "id"),
regexp = "Inputdata must be an object of class sf. Use dyadicdist::ddist()")
}
)
test_that(
"only spatial data.frames/tibbles allowed as input data in ddist_sf()", {
expect_error(dyadicdist::ddist_sf(data = df,
id = "id"),
regexp = "Inputdata must be an object of class sf. Use dyadicdist::ddist()")
expect_error(dyadicdist::ddist_sf(data = mat,
id = "id"),
regexp = "Inputdata must be an object of class sf. Use dyadicdist::ddist()")
}
)
test_that(
"only spatial data.frames/tibbles allowed as input data in ddist_sf()", {
expect_error(dyadicdist::ddist_sf(data = df,
id = "id"),
regexp = "Inputdata must be an object of class sf. Use dyadicdist::ddist()")
expect_error(dyadicdist::ddist_sf(data = mat,
id = "id"),
regexp = "Inputdata must be a data.frame or similar.")
}
)
test_that(
"only spatial data.frames/tibbles allowed as input data in ddist_sf()", {
expect_error(dyadicdist::ddist_sf(data = df,
id = "id"),
regexp = "Inputdata must be an object of class sf. Use dyadicdist::ddist()")
expect_error(dyadicdist::ddist_sf(data = mat,
id = "id"),
regexp = "Inputdata must be an object of class sf. Use dyadicdist::ddist()")
}
)
test_that(
"only data.frames/tibbles allowed as input data in ddist()", {
expect_error(dyadicdist::ddist(data = mat,
id = "id"),
regexp = "Inputdata must be a data.frame or similar.")
}
)
ddist_sf(data = mat, id = "id")
document()
